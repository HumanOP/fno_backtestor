# -*- coding: utf-8 -*-
"""IV-HV Z Score.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18d_yWXJJwCFiN-Yiueoxd3xBuy9vyAKf
"""

import pandas as pd
import numpy as np
import math
from datetime import datetime
from core.backtesting_opt import Strategy, Backtest
from utils.functions import BlackScholes as bs

class OptimizedCalendarIVHV(Strategy):
    """
    A trading strategy that uses the z-score of the normalized IV-HV
    """
    hv_window = 30              # Window size for historical volatility
    zscore_window = 30          # Window size for z-score calculation
    upper_threshold = 1.5       # Z-score threshold to enter trade
    lower_threshold = 0.5       # Z-score threshold to exit trade
    execution_time = "14:45:00" # Daily execution time
    near_term_tte_range = (7, 14)    # TTE range for near-term options
    longer_term_tte_range = (30, 60) # TTE range for longer-term options
    position_id = 0                  # Unique ID for each position

    def init(self):
        """Initialize data structures and variables."""
        self.daily_prices = []              # Store daily spot prices for HV
        self.normalized_diff_history = []   # Store history of normalized differences
        self.executed_today = False         # Flag to ensure single daily execution
        self.last_execution_date = None     # Track last execution date

    def execution_window(self):
        """Check if current time is within the daily execution window."""
        current_time = pd.Timestamp(self.time).time()
        current_date = pd.Timestamp(self.time).date()
        execution_time = pd.Timestamp(self.execution_time).time()

        # Reset execution flag if it's a new day
        if self.last_execution_date != current_date:
            self.executed_today = False
            self.last_execution_date = current_date

        if current_time == execution_time and not self.executed_today:
            self.executed_today = True
            return True
        return False

    def calculate_hv(self):
        """Calculate annualized historical volatility over hv_window days."""
        if len(self.daily_prices) < self.hv_window:
            return None
        closes = self.daily_prices[-self.hv_window:]
        returns = [math.log(closes[i] / closes[i-1]) for i in range(1, len(closes))]
        return np.std(returns) * math.sqrt(252)

    def next(self):
        """Execute the strategy logic at each time step."""
        # Skip if spot price is unavailable
        if self.spot is None or pd.isna(self.spot):
            return

        # Only proceed at execution time
        if not self.execution_window():
            return

        # Record daily spot price
        self.daily_prices.append(self.spot)
        if len(self.daily_prices) > self.hv_window:
            self.daily_prices.pop(0)

        # Calculate historical volatility
        hv = self.calculate_hv()
        if hv is None:
            return

        # Get available time-to-expiry options
        available_ttes = list(self.tte_to_expiry.keys()) if self.tte_to_expiry else []
        near_term_ttes = [
            tte for tte in available_ttes
            if self.near_term_tte_range[0] <= tte <= self.near_term_tte_range[1]
        ]
        if not near_term_ttes:
            return
        near_term_tte = min(near_term_ttes)
        near_term_expiry = self.tte_to_expiry[near_term_tte]

        # Calculate ATM strike
        atm_strike = round(self.spot / 50) * 50
        near_term_ticker = (
            f"NIFTY{pd.Timestamp(near_term_expiry).strftime('%d%b%y').upper()}"
            f"{int(atm_strike)}CE"
        )

        # Retrieve IV for near-term ATM option
        near_term_data = self._data.get_ticker_data(near_term_ticker)
        if near_term_data is None or 'iv' not in near_term_data:
            return
        iv_near = near_term_data['iv']

        # Calculate normalized IV-HV difference
        normalized_diff = (iv_near - hv) / hv if hv != 0 else 0
        self.normalized_diff_history.append(normalized_diff)
        if len(self.normalized_diff_history) > self.zscore_window:
            self.normalized_diff_history.pop(0)

        # Calculate z-score
        if len(self.normalized_diff_history) < self.zscore_window:
            return
        mean_diff = np.mean(self.normalized_diff_history)
        std_diff = np.std(self.normalized_diff_history)
        z_score = 0 if std_diff == 0 else (normalized_diff - mean_diff) / std_diff

        # Trading logic
        active_trades = [t for t in self.active_trades if t.strategy_id == 'calendar']
        current_date = pd.Timestamp(self.time).date()

        if not active_trades:
            # Enter new position if z-score exceeds upper threshold
            if z_score > self.upper_threshold:
                longer_term_ttes = [
                    tte for tte in available_ttes
                    if self.longer_term_tte_range[0] <= tte <= self.longer_term_tte_range[1]
                ]
                if not longer_term_ttes:
                    return
                longer_term_tte = min(longer_term_ttes)
                longer_term_expiry = self.tte_to_expiry[longer_term_tte]
                longer_term_ticker = (
                    f"NIFTY{pd.Timestamp(longer_term_expiry).strftime('%d%b%y').upper()}"
                    f"{int(atm_strike)}CE"
                )

                # Sell near-term option
                self.sell(
                    strategy_id='calendar',
                    position_id=self.position_id,
                    leg_id='sell_leg',
                    ticker=near_term_ticker,
                    quantity=1,
                    stop_loss=None,
                    take_profit=None,
                    tag='Sell near-term'
                )
                # Buy longer-term option
                self.buy(
                    strategy_id='calendar',
                    position_id=self.position_id,
                    leg_id='buy_leg',
                    ticker=longer_term_ticker,
                    quantity=1,
                    stop_loss=None,
                    take_profit=None,
                    tag='Buy longer-term'
                )
                self.position_id += 1
        else:
            # Check exit conditions
            for trade in active_trades:
                if trade.leg_id == 'sell_leg':
                    sell_expiry = datetime.strptime(trade.ticker[-14:-7], "%d%b%y").date()
                    if current_date >= sell_expiry or z_score < self.lower_threshold:
                        # Close all legs of the position
                        for t in active_trades:
                            if t.position_id == trade.position_id:
                                t.close(t.size, tag='Exit condition met')
                        break

# Example usage with walk-forward optimization
if __name__ == "__main__":
    from core.wfo import WalkForwardOptimizer

    wfo = WalkForwardOptimizer(
        strategy=OptimizedCalendarIVHV,
        optimization_params={
            'hv_window': [20, 30, 40],
            'zscore_window': [20, 30, 40],
            'upper_threshold': [1.0, 1.5, 2.0],
            'lower_threshold': [0.0, 0.5, 1.0],
        },
        maximize='Sharpe Ratio',
    )

    wfo.optimize_stock(
        stock='NIFTY',
        timeframe='1min',
        db_path='../core/nifty_1min_desiquant.duckdb',
        exchange='NSE',
        training_candles=6000,
        testing_candles=3000,
        start_date='2022-01-01',
        end_date='2022-12-31',
    )